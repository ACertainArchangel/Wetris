#include <Arduino.h>
#include <Position.h>
#include <string.h>
#include <LCDWIKI_GUI.h>
#include <LCDWIKI_SPI.h>
#include "LcdTetris.h"

namespace LcdTetris {

/// Global Vars
int gameBoard[25][10]; // standard 20x10 tetris board, extra 5 for holding pieces above board
int tickRate = 3; // base speed (you can tie this to stress_level later if you want)
unsigned long timeSinceTick = 0;

int originX = 0;
int originY = 0;
int currentPiece = 0; // 1 = line, 2 = J, 3 = L, 4 = block, 5 = S, 6 = T, 7 = Z
int nextPiece = 0;
int score = 0;

// Position Trackers
int offSetRow = 0;
int offSetCol = 0;
int rotationState = 1;
bool piecePlaced = false;
bool fail = false;

Position currentrotation[4] = {Position(1,0), Position(1,1), Position(1,2), Position(1,3)};
Position previousRender[4] = {Position(1,0), Position(1,1), Position(1,2), Position(1,3)};
int previousOffSet[2] = {0,0}; // offSetX, offSetY

/// Rotation States for each piece
Position stateLine1[4] = {Position(1,0), Position(1,1), Position(1,2), Position(1,3)};
Position stateLine2[4] = {Position(0,2), Position(1,2), Position(2,2), Position(3,2)};
Position stateLine3[4] = {Position(2,0), Position(2,1), Position(2,2), Position(2,3)};
Position stateLine4[4] = {Position(0,1), Position(1,1), Position(2,1), Position(3,1)};

Position stateJ1[4] = {Position(0,0), Position(1,0), Position(1,1), Position(1,2)};
Position stateJ2[4] = {Position(0,1), Position(0,2), Position(1,1), Position(2,1)};
Position stateJ3[4] = {Position(1,0), Position(1,1), Position(1,2), Position(2,2)};
Position stateJ4[4] = {Position(0,1), Position(1,1), Position(2,0), Position(2,1)};

Position stateL1[4] = {Position(0,2), Position(1,0), Position(1,1), Position(1,2)};
Position stateL2[4] = {Position(0,1), Position(1,1), Position(2,1), Position(2,2)};
Position stateL3[4] = {Position(1,0), Position(1,1), Position(1,2), Position(2,0)};
Position stateL4[4] = {Position(0,0), Position(0,1), Position(1,1), Position(2,1)};

Position stateBlock1[4] = {Position(0,0), Position(0,1), Position(1,0), Position(1,1)};

Position stateS1[4] = {Position(0,1), Position(0,2), Position(1,0), Position(1,1)};
Position stateS2[4] = {Position(0,1), Position(1,1), Position(1,2), Position(2,2)};
Position stateS3[4] = {Position(1,1), Position(1,2), Position(2,0), Position(2,1)};
Position stateS4[4] = {Position(0,0), Position(1,0), Position(1,1), Position(2,1)};

Position stateT1[4] = {Position(0,1), Position(1,0), Position(1,1), Position(1,2)};
Position stateT2[4] = {Position(0,1), Position(1,1), Position(1,2), Position(2,1)};
Position stateT3[4] = {Position(1,0), Position(1,1), Position(1,2), Position(2,1)};
Position stateT4[4] = {Position(0,1), Position(1,0), Position(1,1), Position(2,1)};

Position stateZ1[4] = {Position(0,0), Position(0,1), Position(1,1), Position(1,2)};
Position stateZ2[4] = {Position(0,2), Position(1,1), Position(1,2), Position(2,1)};
Position stateZ3[4] = {Position(1,0), Position(1,1), Position(2,1), Position(2,2)};
Position stateZ4[4] = {Position(0,1), Position(1,0), Position(1,1), Position(2,0)};

// Input pins
const int button1Pin = 6;
const int button2Pin = 5;
const int button3Pin = 4;
int button1Val;
int button2Val;
int button3Val;

int button1LastVal = LOW;
int button2LastVal = LOW;
int button3LastVal = LOW;

// LCD params
#define MODEL ST7796S
#define CS   10    
#define CD   9
#define RST  8
#define LED  7   // if you don't need to control LED, tie it to 3.3V

LCDWIKI_SPI mylcd(MODEL,CS,CD,RST,LED);

// colours
#define  BLACK   0x0000
#define BLUE    0x001F
#define RED     0xF800
#define GREEN   0x07E0
#define CYAN    0x07FF
#define MAGENTA 0xF81F
#define YELLOW  0xFFE0
#define ORANGE  0xFB20

// ---- INTERNAL HELPERS ----
void initBoard();
void initPiece();
void clearScreen();
void renderBoard();
void renderMisc();
void renderPiece();
void processInputs();
void rotationCopy();
bool checkFail();
bool pieceFits();
void placePiece();
void checkTetris();
void movePieceDown();
void moveLeft();
void moveRight();
void rotatePieceCW();
void rotatePieceCCW();

// ---- Array helpers ----
void copyArray(Position* source, Position* destination, int len) {
  memcpy(destination, source, sizeof(source[0]) * len);
}

void rotationCopy() {
  int length = 4;
  switch (currentPiece) {
    case 1:
      if (rotationState == 1)      copyArray(stateLine1, currentrotation, length);
      else if (rotationState == 2) copyArray(stateLine2, currentrotation, length);
      else if (rotationState == 3) copyArray(stateLine3, currentrotation, length);
      else                        copyArray(stateLine4, currentrotation, length);
      break;
    case 2:
      if (rotationState == 1)      copyArray(stateJ1, currentrotation, length);
      else if (rotationState == 2) copyArray(stateJ2, currentrotation, length);
      else if (rotationState == 3) copyArray(stateJ3, currentrotation, length);
      else                        copyArray(stateJ4, currentrotation, length);
      break;
    case 3:
      if (rotationState == 1)      copyArray(stateL1, currentrotation, length);
      else if (rotationState == 2) copyArray(stateL2, currentrotation, length);
      else if (rotationState == 3) copyArray(stateL3, currentrotation, length);
      else                        copyArray(stateL4, currentrotation, length);
      break;
    case 4:
      copyArray(stateBlock1, currentrotation, length);
      break;
    case 5:
      if (rotationState == 1)      copyArray(stateS1, currentrotation, length);
      else if (rotationState == 2) copyArray(stateS2, currentrotation, length);
      else if (rotationState == 3) copyArray(stateS3, currentrotation, length);
      else                        copyArray(stateS4, currentrotation, length);
      break;
    case 6:
      if (rotationState == 1)      copyArray(stateT1, currentrotation, length);
      else if (rotationState == 2) copyArray(stateT2, currentrotation, length);
      else if (rotationState == 3) copyArray(stateT3, currentrotation, length);
      else                        copyArray(stateT4, currentrotation, length);
      break;
    case 7:
      if (rotationState == 1)      copyArray(stateZ1, currentrotation, length);
      else if (rotationState == 2) copyArray(stateZ2, currentrotation, length);
      else if (rotationState == 3) copyArray(stateZ3, currentrotation, length);
      else                        copyArray(stateZ4, currentrotation, length);
      break;
  }
}

bool isCellEmpty(int row, int col) {
  return gameBoard[row][col] == 0;
}

bool isRowEmpty(int row) {
  for (int x = 0; x < 10; x++) {
    if (gameBoard[row][x] != 0) return false;
  }
  return true;
}

bool isRowFull(int row) {
  for (int x = 0; x < 10; x++) {
    if (gameBoard[row][x] == 0) return false;
  }
  return true;
}

bool pieceFits() {
  rotationCopy();
  for (int x = 0; x < 4; x++) {
    int r = currentrotation[x].getRow() + offSetRow;
    int c = currentrotation[x].getCol() + offSetCol;
    if (r > 24 || r < 0 || c > 9 || c < 0) {
      return false;
    }
    if (gameBoard[r][c] != 0) {
      return false;
    }
  }
  return true;
}

void processInputs() {
  button1Val = digitalRead(button1Pin);
  button2Val = digitalRead(button2Pin);
  button3Val = digitalRead(button3Pin);

  if (button1Val == HIGH && button1LastVal == LOW) {
    moveLeft();
  }
  if (button2Val == HIGH && button2LastVal == LOW) {
    moveRight();
  }
  if (button3Val == HIGH && button3LastVal == LOW) {
    rotatePieceCW();
  }
  button1LastVal = button1Val;
  button2LastVal = button2Val;
  button3LastVal = button3Val;
}

// Board actions
void clearRow(int row) {
  for (int x = 0; x < 10; x++) {
    gameBoard[row][x] = 0;
  }
}

void moveBoardDown() {
  for (int x = 23; x > 0; x--) {
    for (int y = 0; y < 10; y++) {
      if (gameBoard[x + 1][y] == 0) {
        gameBoard[x + 1][y] = gameBoard[x][y];
        gameBoard[x][y] = 0;
      }
    }
  }
}

void checkTetris() {
  bool rowCleared = false;
  for (int x = 0; x < 25; x++) {
    if (isRowFull(x)) {
      clearRow(x);
      score++;
      rowCleared = true;
    }
  }
  if (rowCleared) {
    moveBoardDown();
    clearScreen();
  }
  renderBoard();
}

bool checkFail() {
  return !isRowEmpty(3);
}

// Piece actions
void rotatePieceCW() {
  if (rotationState < 4) rotationState++;
  else rotationState = 1;
  rotationCopy();
  if (!pieceFits()) rotatePieceCCW();
}

void rotatePieceCCW() {
  if (rotationState > 1) rotationState--;
  else rotationState = 4;
  rotationCopy();
  if (!pieceFits()) rotatePieceCW();
}

void movePiece(int row, int col) {
  offSetRow += row;
  offSetCol += col;
}

void moveLeft() {
  offSetCol--;
  if (!pieceFits()) moveRight();
}

void moveRight() {
  offSetCol++;
  if (!pieceFits()) moveLeft();
}

void movePieceDown() {
  movePiece(1, 0);
  if (!pieceFits()) {
    movePiece(-1, 0);
    placePiece();
  }
  if (offSetRow >= 23) {
    placePiece();
  }
}

void placePiece() {
  rotationCopy();
  for (int x = 0; x < 4; x++) {
    int r = currentrotation[x].getRow() + offSetRow;
    int c = currentrotation[x].getCol() + offSetCol;
    gameBoard[r][c] = currentPiece;
  }
  piecePlaced = true;
  checkTetris();
  renderBoard();
}

// System
void initBoard() {
  for (int x = 0; x < 25; x++) {
    for (int y = 0; y < 10; y++) {
      gameBoard[x][y]= 0;
    }
  }
  score = 0;
}

void initPiece() {
  originX = 0;
  originY = 0;
  offSetRow = 3;
  offSetCol = 5;
  rotationState = 1;

  if (nextPiece == 0) {
    nextPiece = random(1, 8);
  }

  currentPiece = nextPiece;
  nextPiece = random(1, 8); // 1–7
  rotationCopy();
}

// Rendering
void clearScreen() {
  mylcd.Fill_Screen(BLACK);
}

void setColor(int ID) {
  switch (ID) {
    case 1: mylcd.Set_Draw_color(CYAN);    break;
    case 2: mylcd.Set_Draw_color(BLUE);    break;
    case 3: mylcd.Set_Draw_color(ORANGE);  break;
    case 4: mylcd.Set_Draw_color(YELLOW);  break;
    case 5: mylcd.Set_Draw_color(GREEN);   break;
    case 6: mylcd.Set_Draw_color(MAGENTA); break;
    case 7: mylcd.Set_Draw_color(RED);     break;
  }
}

void renderMisc() {
  mylcd.Set_Text_Mode(0);
  mylcd.Set_Text_colour(CYAN);
  mylcd.Set_Text_Size(2);
  mylcd.Print_Number_Int(score, 200, 104, 0, ' ', 16);

  mylcd.Set_Text_colour(BLUE);
  mylcd.Set_Text_Size(2);
  switch (currentPiece) {
    case 1: mylcd.Print_String("I Piece",      200, 120); break;
    case 2: mylcd.Print_String("J Piece",      200, 120); break;
    case 3: mylcd.Print_String("L Piece",      200, 120); break;
    case 4: mylcd.Print_String("Block Piece",  200, 120); break;
    case 5: mylcd.Print_String("S Piece",      200, 120); break;
    case 6: mylcd.Print_String("T Piece",      200, 120); break;
    case 7: mylcd.Print_String("Z Piece",      200, 120); break;
  }
}

void renderBoard() {
  int x1 = 0;
  int y1 = 0;
  int size = 19;

  // outlines
  for (int x = 0; x < 25; x++) {
    for (int y = 0; y < 10; y++) {
      if (gameBoard[x][y] >= 1) {
        setColor(gameBoard[x][y]);
        mylcd.Draw_Rectangle(x1, y1, x1 + size, y1 + size);
      }
      x1 += size;
    }
    y1 += size;
    x1 = 0;
  }

  x1 = 0;
  y1 = 0;

  // filled blocks
  for (int x = 0; x < 25; x++) {
    for (int y = 0; y < 10; y++) {
      if (gameBoard[x][y] >= 1) {
        setColor(gameBoard[x][y]);
        mylcd.Fill_Rectangle(x1, y1, x1 + size, y1 + size);
      }
      x1 += size;
    }
    y1 += size;
    x1 = 0;
  }
}

void renderPiece() {
  mylcd.Set_Draw_color(0, 0, 0);
  int startingX = 0;
  int startingY = 0;
  int endX = 0;
  int endY = 0;
  int size = 19;

  // erase old piece
  for (int x = 0; x < 4; x++) {
    if (previousRender[x].getRow() == 0 && previousOffSet[0] == 0) {
      startingY = 0;
      endY = 19;
    } else {
      startingY = (previousRender[x].getRow() + previousOffSet[0]) * size;
      endY     = (previousRender[x].getRow() + previousOffSet[0] + 1) * size;
    }

    if (previousRender[x].getCol() == 0 && previousOffSet[1] == 0) {
      startingX = 0;
      endX = 19;
    } else {
      startingX = (previousRender[x].getCol() + previousOffSet[1]) * size;
      endX     = (previousRender[x].getCol() + previousOffSet[1] + 1) * size;
    }
    mylcd.Draw_Rectangle(startingX, startingY, endX, endY);
  }

  // draw current piece
  setColor(currentPiece);
  copyArray(currentrotation, previousRender, 4);
  previousOffSet[0] = offSetRow;
  previousOffSet[1] = offSetCol;

  for (int x = 0; x < 4; x++) {
    if (currentrotation[x].getRow() == 0 && offSetRow == 0) {
      startingY = 0;
      endY = 19;
    } else {
      startingY = (currentrotation[x].getRow() + offSetRow) * size;
      endY     = (currentrotation[x].getRow() + offSetRow + 1) * size;
    }

    if (currentrotation[x].getCol() == 0 && offSetCol == 0) {
      startingX = 0;
      endX = 19;
    } else {
      startingX = (currentrotation[x].getCol() + offSetCol) * size;
      endX     = (currentrotation[x].getCol() + offSetCol + 1) * size;
    }

    mylcd.Draw_Rectangle(startingX, startingY, endX, endY);
  }
}

// ---- PUBLIC INTERFACE ----

void setup() {
  // Serial.begin is already called in your main; optional here:
  // Serial.begin(9600);

  pinMode(button1Pin, INPUT_PULLUP);
  pinMode(button2Pin, INPUT_PULLUP);
  pinMode(button3Pin, INPUT_PULLUP);

  randomSeed(analogRead(0));

  mylcd.Init_LCD();
  clearScreen();

  initBoard();
  initPiece();
  renderBoard();

  timeSinceTick = millis();
}

bool update(uint8_t stress_level) {
  // Example: convert stress_level (0–255) into drop speed
  // Higher stress -> faster game
  unsigned long now = millis();
  unsigned long baseDelay = 400; // ms
  unsigned long minDelay  = 80;  // ms
  unsigned long dropDelay = baseDelay - ((baseDelay - minDelay) * stress_level) / 255;

  if (piecePlaced) {
    initPiece();
    piecePlaced = false;
  }

  processInputs();

  if (now - timeSinceTick >= dropDelay) {
    movePieceDown();
    fail = checkFail();
    timeSinceTick = now;
  }

  renderPiece();
  renderMisc();

  return fail;
}

int get_score() {
  return score;
}

void thanks_winner() {
  mylcd.Fill_Screen(BLACK);
  mylcd.Set_Text_Mode(0);
  mylcd.Set_Text_colour(GREEN);
  mylcd.Set_Text_Size(3);
  mylcd.Print_String("YOU WIN!", 40, 60);

  mylcd.Set_Text_colour(CYAN);
  mylcd.Set_Text_Size(2);
  mylcd.Print_String("Score:", 40, 100);
  mylcd.Print_Number_Int(score, 140, 100, 0, ' ', 10);
}

void thanks_looser() {
  mylcd.Fill_Screen(BLACK);
  mylcd.Set_Text_Mode(0);
  mylcd.Set_Text_colour(RED);
  mylcd.Set_Text_Size(3);
  mylcd.Print_String("YOU LOSE", 40, 60);

  mylcd.Set_Text_colour(CYAN);
  mylcd.Set_Text_Size(2);
  mylcd.Print_String("Score:", 40, 100);
  mylcd.Print_Number_Int(score, 140, 100, 0, ' ', 10);
}

} // namespace LcdTetris
